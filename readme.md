# Описание предлагаемого решения
## Задание 1
Партиционированные таблицы выбраны т.к. 
1. Когда в выборке или изменении данных задействована большая
часть одной секции, последовательное сканирование этой секции
 может выполняться гораздо быстрее, чем случайный доступ по
 индексу к данным, разбросанным по всей таблице.
2. удаление партиций также полностью исключают
накладные расходы, связанные с выполнением VACUUM после DELETE.
3. Редко используемые данные можно перенести
на более дешёвые и медленные носители.

**НО следует иметь ввиду** 
1. Механизм автоматического создания соответствующих индексов во всех секциях отсутствует, поэтому индексы нужно добавлять в каждую секцию отдельно. Это также означает, что невозможно создать первичный ключ, ограничение уникальности или ограничение исключения, охватывающие все секции; такие ограничения возможны только в отдельных секциях.

2. Так как в секционированных таблицах первичные ключи не поддерживаются, на секционированные таблицы не могут ссылаться внешние ключи, так же как и внешние ключи в сторонних таблицах не могут ссылаться на какие-либо другие таблицы.

3. Триггеры уровня строк при необходимости должны определяться в отдельных секциях, а не в секционированной таблице.

4. Потребуется создавать партиции ежедневно. Для этого написан скрипт , который находится в файле **convert.ipynb**

        reate_ddl_partition_table(year, month, day) 


![Image alt](img/er_diagramm.jpg)

Так выглядит со стороны теории множеств

![Image alt](img/eiler_circle.jpg)

## Задание 2
Решение приложено в файле **sql_scripts/task.sql**

Результат выполнения sql скрипта
![Image alt](img/show_result.png)

# Запуск решения
1. скачать данные с https://www.moex.com/ru/orders?orderlogs (см. Срочный рынок, Тип-А, файл _fut_ord.csv).
2. Запустить последовательно блоки кода из файла **convert.ipynb**
3. Изменить расположение расшаренной папки в docker-compose, на то, которое соответствует на Вашем хосте
   
   `` - /home/denis/Projects/BSPB_testovoe/:/etc/data ``
  
4. из директории проекта выполнить команду
   
           docker compose up

5. Выполнить скрипт загрузки данных из файла **sql_scripts/dml.sql**
6. Чтобы оптимизация партиций работала, то вывод команды
   
        show constraint_exclusion;

должен быть 

        partition

PostgreSQL будет пропускать партиции, которые не могут содержать совпадающие строки


